# ЭФМО-01-25 Буров М.А. ПР8

# Описание проекта
Работа с MongoDB: подключение, создание коллекции, CRUD-операции.

# Требования к проекту
* Go 1.25+
* Docker
* MongoDB
* Git

# Версия Go
<img width="317" height="55" alt="image" src="https://github.com/user-attachments/assets/43f9087b-95b9-4c7d-86e9-746258c45c63" />

# Команды запуска
```
docker compose up -d
cp .env.example .env   # PowerShell: Copy-Item .env.example .env
go run ./cmd/api
```

# Цели:
-	Понять базовые принципы документной БД MongoDB (документ, коллекция, BSON, _id:ObjectID).
-	Научиться подключаться к MongoDB из Go с использованием официального драйвера.
-	Создать коллекцию, индексы и реализовать CRUD для одной сущности (например, notes).
-	Отработать фильтрацию, пагинацию, обновления (в т.ч. частичные), удаление и обработку ошибок.

# Структура проекта
Дерево структуры проекта: 
```
pz8-mongo/
├── internal/
│   ├── db/
│   │   └── mongo.go
│   └── notes/
│       ├── model.go
│       ├── repo.go
│       └── handler.go
├── cmd/
│   └── api/
│       └── main.go
├── docker-compose.yml
└── .env.example
```

# Скриншоты

Подготовка окружения:

<img width="969" height="687" alt="image" src="https://github.com/user-attachments/assets/ac827d74-c4e7-4e5f-8515-90e4be998ee6" />

Создать:

<img width="1376" height="681" alt="image" src="https://github.com/user-attachments/assets/025d11ef-097e-452f-83d1-540b1ca5c78b" />

Список:

<img width="1377" height="726" alt="image" src="https://github.com/user-attachments/assets/970b3c38-624f-428e-9a24-b9d6ba59f1f2" />

Получить по ID:

<img width="1378" height="659" alt="image" src="https://github.com/user-attachments/assets/8b2d1fae-3e45-44cf-a26e-20ea10f47496" />

Частичное обновление:

<img width="1370" height="678" alt="image" src="https://github.com/user-attachments/assets/556b9302-8082-4c9a-bdeb-9c021fb67806" />

Удаление:

<img width="1376" height="537" alt="image" src="https://github.com/user-attachments/assets/1acc1e4d-19a4-47c6-891a-9ff320858c36" />

# Ответы на контрольные вопросы

1.	Чем документная модель MongoDB принципиально отличается от реляционной? Когда она удобнее?

Реляционная модель (PostgreSQL, MySQL) организует данные в таблицы с фиксированной схемой и строгими связями. MongoDB хранит данные в коллекциях документов в формате BSON (JSON-подобный), где каждый документ может иметь разные поля и вложенные структуры. Никакой предварительной схемы не требуется.

Когда MongoDB удобнее SQL:
-	Динамическая и изменяющаяся структура (например, заметки, профили пользователей, каталоги товаров).
-	Хранение вложенных объектов (адреса, массивы тегов, списки файлов).
-	Высокая скорость вставки и выборки документов.
-	Масштабирование по принципу sharding (распределение коллекции по нескольким узлам).

2.	Что такое ObjectID и зачем нужен _id? Как корректно парсить/валидировать его в Go?

ObjectID — это специальный тип уникального идентификатора в MongoDB, который создаётся автоматически при вставке документа. Поле _id обязательно в каждом документе и служит первичным ключом. ObjectID состоит из 12 байт: 4 байта времени, 5 байт случайного значения и 3 байта счётчика, что гарантирует глобальную уникальность без центрального координатора.

В Go ObjectID представлен типом primitive.ObjectID. Для парсинга из строки используется primitive.ObjectIDFromHex(hexString), который вернёт ошибку, если строка некорректна.

3.	Какие операции CRUD предоставляет драйвер MongoDB и какие операторы обновления вы знаете?

CRUD-операции в MongoDB драйвере: InsertOne / InsertMany (создание), FindOne / Find (чтение), UpdateOne / UpdateMany / FindOneAndUpdate (обновление), DeleteOne / DeleteMany (удаление).

Операторы обновления: $set (установить значение), $unset (удалить поле), $push (добавить элемент в массив), $pull (удалить элемент из массива), $currentDate (установить текущее время).

4.	Как устроены индексы в MongoDB? Как создать уникальный индекс и чем он грозит при вставке?

Индексы в MongoDB ускоряют поиск по полям, аналогично SQL. Типы: обычный индекс (по одному полю), составной (по нескольким полям), уникальный (не допускает дубликатов), TTL (автоудаление документов по истечении времени).

Уникальный индекс создаётся с опцией SetUnique(true):
```
col.Indexes().CreateOne(ctx, mongo.IndexModel{
    Keys: bson.D{{Key: "title", Value: 1}},
    Options: options.Index().SetUnique(true),
})
```
При попытке вставить документ с дубликатом значения возникает ошибка типа duplicate key error (код 11000). Приложение должно обработать эту ошибку и вернуть клиенту HTTP 409 Conflict.

5.	Почему важно использовать context.WithTimeout при вызовах к базе? Что произойдет при его срабатывании?

Context с таймаутом предотвращает зависание приложения при сетевых проблемах или медленных запросах. Если операция с БД не завершится за указанное время, контекст отменится, и операция вернёт ошибку типа context.DeadlineExceeded.

Без таймаута приложение может зависнуть на неопределённое время при потере соединения с MongoDB. С таймаутом приложение сможет вернуть клиенту ошибку и продолжить работать. Рекомендуется использовать таймауты 3-10 секунд для обычных операций и 30 секунд для длинных aggregation pipeline.
