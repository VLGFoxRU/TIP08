# ЭФМО-01-25 Буров М.А. ПР8

# Описание проекта
Работа с MongoDB: подключение, создание коллекции, CRUD-операции.

# Требования к проекту
* Go 1.25+
* Docker
* Git

# Версия Go
<img width="317" height="55" alt="image" src="https://github.com/user-attachments/assets/43f9087b-95b9-4c7d-86e9-746258c45c63" />

# Версия PostgreSQL
<img width="276" height="55" alt="image" src="https://github.com/user-attachments/assets/bca8a5ed-eb3b-4b1c-9eee-16fb8ec409e8" />

# Команды запуска
```
docker compose up -d
cp .env.example .env   # PowerShell: Copy-Item .env.example .env
go run ./cmd/api
```

# Цели:
-	Понять базовые принципы документной БД MongoDB (документ, коллекция, BSON, _id:ObjectID).
-	Научиться подключаться к MongoDB из Go с использованием официального драйвера.
-	Создать коллекцию, индексы и реализовать CRUD для одной сущности (например, notes).
-	Отработать фильтрацию, пагинацию, обновления (в т.ч. частичные), удаление и обработку ошибок.

# Структура проекта
Дерево структуры проекта: 
```
pz8-mongo/
├── internal/
│   ├── db/
│   │   └── mongo.go
│   └── notes/
│       ├── model.go
│       ├── repo.go
│       └── handler.go
├── cmd/
│   └── api/
│       └── main.go
├── docker-compose.yml
└── .env.example
```

# Скриншоты

Создать:

Список:

Получить по ID:

Частичное обновление:

Удаление:

# Ответы на контрольные вопросы

1.	Чем документная модель MongoDB принципиально отличается от реляционной? Когда она удобнее?

Реляционная модель (PostgreSQL, MySQL) организует данные в таблицы с фиксированной схемой и строгими связями. MongoDB хранит данные в коллекциях документов в формате BSON (JSON-подобный), где каждый документ может иметь разные поля и вложенные структуры. Никакой предварительной схемы не требуется.

Когда MongoDB удобнее SQL:
-	Динамическая и изменяющаяся структура (например, заметки, профили пользователей, каталоги товаров).
-	Хранение вложенных объектов (адреса, массивы тегов, списки файлов).
-	Высокая скорость вставки и выборки документов.
-	Масштабирование по принципу sharding (распределение коллекции по нескольким узлам).

2.	Что такое ObjectID и зачем нужен _id? Как корректно парсить/валидировать его в Go?

ObjectID — это специальный тип уникального идентификатора в MongoDB, который создаётся автоматически при вставке документа. Поле _id обязательно в каждом документе и служит первичным ключом. ObjectID состоит из 12 байт: 4 байта времени, 5 байт случайного значения и 3 байта счётчика, что гарантирует глобальную уникальность без центрального координатора.

В Go ObjectID представлен типом primitive.ObjectID. Для парсинга из строки используется primitive.ObjectIDFromHex(hexString), который вернёт ошибку, если строка некорректна.

3.	Какие операции CRUD предоставляет драйвер MongoDB и какие операторы обновления вы знаете?

CRUD-операции в MongoDB драйвере: InsertOne / InsertMany (создание), FindOne / Find (чтение), UpdateOne / UpdateMany / FindOneAndUpdate (обновление), DeleteOne / DeleteMany (удаление).

Операторы обновления: $set (установить значение), $unset (удалить поле), $push (добавить элемент в массив), $pull (удалить элемент из массива), $currentDate (установить текущее время).

4.	Как устроены индексы в MongoDB? Как создать уникальный индекс и чем он грозит при вставке?

Индексы в MongoDB ускоряют поиск по полям, аналогично SQL. Типы: обычный индекс (по одному полю), составной (по нескольким полям), уникальный (не допускает дубликатов), TTL (автоудаление документов по истечении времени).

Уникальный индекс создаётся с опцией SetUnique(true):
```
col.Indexes().CreateOne(ctx, mongo.IndexModel{
    Keys: bson.D{{Key: "title", Value: 1}},
    Options: options.Index().SetUnique(true),
})
```
При попытке вставить документ с дубликатом значения возникает ошибка типа duplicate key error (код 11000). Приложение должно обработать эту ошибку и вернуть клиенту HTTP 409 Conflict.

5.	Почему важно использовать context.WithTimeout при вызовах к базе? Что произойдет при его срабатывании?

Context с таймаутом предотвращает зависание приложения при сетевых проблемах или медленных запросах. Если операция с БД не завершится за указанное время, контекст отменится, и операция вернёт ошибку типа context.DeadlineExceeded.

Без таймаута приложение может зависнуть на неопределённое время при потере соединения с MongoDB. С таймаутом приложение сможет вернуть клиенту ошибку и продолжить работать. Рекомендуется использовать таймауты 3-10 секунд для обычных операций и 30 секунд для длинных aggregation pipeline.
